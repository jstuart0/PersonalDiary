package com.jstuart0.personaldiary.data.local.dao

import androidx.room.*
import com.jstuart0.personaldiary.data.local.entity.EntryEntity
import com.jstuart0.personaldiary.data.local.entity.EntryTagEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO for Entry operations
 */
@Dao
interface EntryDao {

    @Query("SELECT * FROM entries WHERE userId = :userId ORDER BY createdAt DESC")
    fun getEntriesFlow(userId: String): Flow<List<EntryEntity>>

    @Query("SELECT * FROM entries WHERE userId = :userId ORDER BY createdAt DESC LIMIT :limit OFFSET :offset")
    suspend fun getEntries(userId: String, limit: Int, offset: Int): List<EntryEntity>

    @Query("SELECT * FROM entries WHERE entryId = :entryId")
    suspend fun getEntry(entryId: String): EntryEntity?

    @Query("SELECT * FROM entries WHERE entryId = :entryId")
    fun getEntryFlow(entryId: String): Flow<EntryEntity?>

    @Query("SELECT * FROM entries WHERE userId = :userId AND syncStatus = :status")
    suspend fun getEntriesByStatus(userId: String, status: String): List<EntryEntity>

    @Query("SELECT * FROM entries WHERE userId = :userId AND source = :source ORDER BY createdAt DESC")
    fun getEntriesBySource(userId: String, source: String): Flow<List<EntryEntity>>

    @Query("SELECT * FROM entries WHERE userId = :userId AND createdAt BETWEEN :startTime AND :endTime ORDER BY createdAt DESC")
    fun getEntriesByDateRange(userId: String, startTime: Long, endTime: Long): Flow<List<EntryEntity>>

    @Query("SELECT * FROM entries WHERE externalPostId = :externalPostId")
    suspend fun getEntryByExternalId(externalPostId: String): EntryEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(entry: EntryEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(entries: List<EntryEntity>)

    @Update
    suspend fun update(entry: EntryEntity)

    @Delete
    suspend fun delete(entry: EntryEntity)

    @Query("DELETE FROM entries WHERE userId = :userId")
    suspend fun deleteAllForUser(userId: String)

    @Query("UPDATE entries SET syncStatus = :status WHERE entryId = :entryId")
    suspend fun updateSyncStatus(entryId: String, status: String)

    @Query("SELECT COUNT(*) FROM entries WHERE userId = :userId")
    suspend fun getEntryCount(userId: String): Int

    // Tag operations
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTag(tag: EntryTagEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTags(tags: List<EntryTagEntity>)

    @Query("SELECT tagName FROM entry_tags WHERE entryId = :entryId")
    suspend fun getTagsForEntry(entryId: String): List<String>

    @Query("SELECT tagName FROM entry_tags WHERE entryId = :entryId")
    fun getTagsForEntryFlow(entryId: String): Flow<List<String>>

    @Query("DELETE FROM entry_tags WHERE entryId = :entryId")
    suspend fun deleteTagsForEntry(entryId: String)

    @Query("SELECT DISTINCT tagName FROM entry_tags ORDER BY tagName ASC")
    fun getAllTags(): Flow<List<String>>

    @Query("SELECT DISTINCT tagName FROM entry_tags WHERE autoGenerated = 0 ORDER BY tagName ASC")
    fun getUserTags(): Flow<List<String>>

    @Transaction
    suspend fun insertEntryWithTags(entry: EntryEntity, tags: List<String>) {
        insert(entry)
        deleteTagsForEntry(entry.entryId)
        if (tags.isNotEmpty()) {
            val tagEntities = tags.map { tagName ->
                EntryTagEntity(
                    entryId = entry.entryId,
                    tagName = tagName,
                    autoGenerated = false
                )
            }
            insertTags(tagEntities)
        }
    }

    @Transaction
    suspend fun updateEntryWithTags(entry: EntryEntity, tags: List<String>) {
        update(entry)
        deleteTagsForEntry(entry.entryId)
        if (tags.isNotEmpty()) {
            val tagEntities = tags.map { tagName ->
                EntryTagEntity(
                    entryId = entry.entryId,
                    tagName = tagName,
                    autoGenerated = false
                )
            }
            insertTags(tagEntities)
        }
    }
}
