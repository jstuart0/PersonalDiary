//
//  CoreDataModels.swift
//  PersonalDiary
//
//  Created by Claude Code on 2025-10-31.
//  Copyright Â© 2025 Personal Diary Platform. All rights reserved.
//

import CoreData
import Foundation

// MARK: - EntryEntity

@objc(EntryEntity)
public class EntryEntity: NSManagedObject, Identifiable {
    @NSManaged public var id: UUID
    @NSManaged public var title: String?
    @NSManaged public var content: String
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    @NSManaged public var isEncrypted: Bool
    @NSManaged public var encryptionTier: String
    @NSManaged public var encryptedContent: Data?
    @NSManaged public var contentHash: String?
    @NSManaged public var source: String
    @NSManaged public var sourceID: String?
    @NSManaged public var syncStatus: String
    @NSManaged public var lastSyncedAt: Date?
    @NSManaged public var serverID: String?
    @NSManaged public var serverUpdatedAt: Date?
    @NSManaged public var isDeleted: Bool
    @NSManaged public var deletedAt: Date?

    // Relationships
    @NSManaged public var tags: NSSet?
    @NSManaged public var media: NSSet?
}

// MARK: - EntryEntity + Convenience

extension EntryEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<EntryEntity> {
        return NSFetchRequest<EntryEntity>(entityName: "EntryEntity")
    }

    public var tagsArray: [TagEntity] {
        let set = tags as? Set<TagEntity> ?? []
        return set.sorted { $0.name < $1.name }
    }

    public var mediaArray: [MediaEntity] {
        let set = media as? Set<MediaEntity> ?? []
        return set.sorted { $0.createdAt < $1.createdAt }
    }

    /// Converts Core Data entity to domain model
    func toDomainModel() throws -> Entry {
        // Decrypt content if encrypted
        let decryptedContent: String
        if isEncrypted, let encryptedData = encryptedContent {
            let tier = EncryptionTier(rawValue: encryptionTier) ?? .e2e
            let service = EncryptionServiceFactory.service(for: tier)
            decryptedContent = try service.decryptText(encryptedData)
        } else {
            decryptedContent = content
        }

        return Entry(
            id: id,
            title: title,
            content: decryptedContent,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isEncrypted: isEncrypted,
            encryptionTier: EncryptionTier(rawValue: encryptionTier) ?? .e2e,
            tags: tagsArray.map { $0.toDomainModel() },
            media: mediaArray.compactMap { try? $0.toDomainModel() },
            source: EntrySource(rawValue: source) ?? .manual,
            sourceID: sourceID,
            syncStatus: SyncStatus(rawValue: syncStatus) ?? .pending,
            lastSyncedAt: lastSyncedAt,
            serverID: serverID,
            serverUpdatedAt: serverUpdatedAt
        )
    }

    /// Updates entity from domain model
    func update(from entry: Entry, context: NSManagedObjectContext) throws {
        id = entry.id
        title = entry.title
        createdAt = entry.createdAt
        updatedAt = entry.updatedAt
        isEncrypted = entry.isEncrypted
        encryptionTier = entry.encryptionTier.rawValue
        source = entry.source.rawValue
        sourceID = entry.sourceID
        syncStatus = entry.syncStatus.rawValue
        lastSyncedAt = entry.lastSyncedAt
        serverID = entry.serverID
        serverUpdatedAt = entry.serverUpdatedAt

        // Encrypt content if needed
        if entry.isEncrypted {
            let service = EncryptionServiceFactory.service(for: entry.encryptionTier)
            encryptedContent = try service.encryptText(entry.content)
            content = "" // Clear plaintext
            contentHash = entry.content.sha256Hash()
        } else {
            content = entry.content
            encryptedContent = nil
            contentHash = entry.content.sha256Hash()
        }

        // Update tags
        if let existingTags = tags as? Set<TagEntity> {
            for tag in existingTags {
                context.delete(tag)
            }
        }

        var newTags = Set<TagEntity>()
        for tag in entry.tags {
            let tagEntity = TagEntity(context: context)
            tagEntity.id = tag.id
            tagEntity.name = tag.name
            tagEntity.isAutoGenerated = tag.isAutoGenerated
            newTags.insert(tagEntity)
        }
        tags = newTags as NSSet
    }
}

// MARK: - TagEntity

@objc(TagEntity)
public class TagEntity: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var name: String
    @NSManaged public var isAutoGenerated: Bool
    @NSManaged public var createdAt: Date
    @NSManaged public var entries: NSSet?
}

extension TagEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<TagEntity> {
        return NSFetchRequest<TagEntity>(entityName: "TagEntity")
    }

    func toDomainModel() -> Tag {
        Tag(
            id: id,
            name: name,
            isAutoGenerated: isAutoGenerated
        )
    }
}

// MARK: - MediaEntity

@objc(MediaEntity)
public class MediaEntity: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var entryID: UUID
    @NSManaged public var type: String
    @NSManaged public var localPath: String?
    @NSManaged public var serverURL: String?
    @NSManaged public var thumbnailPath: String?
    @NSManaged public var isEncrypted: Bool
    @NSManaged public var encryptionKey: Data?
    @NSManaged public var fileSize: Int64
    @NSManaged public var mimeType: String
    @NSManaged public var width: Int32
    @NSManaged public var height: Int32
    @NSManaged public var duration: Double
    @NSManaged public var createdAt: Date
    @NSManaged public var uploadStatus: String
    @NSManaged public var uploadedAt: Date?
    @NSManaged public var entry: EntryEntity?
}

extension MediaEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<MediaEntity> {
        return NSFetchRequest<MediaEntity>(entityName: "MediaEntity")
    }

    func toDomainModel() throws -> Media {
        Media(
            id: id,
            entryID: entryID,
            type: MediaType(rawValue: type) ?? .photo,
            localPath: localPath,
            serverURL: serverURL != nil ? URL(string: serverURL!) : nil,
            thumbnailPath: thumbnailPath,
            isEncrypted: isEncrypted,
            fileSize: fileSize,
            mimeType: mimeType,
            width: Int(width),
            height: Int(height),
            duration: duration,
            createdAt: createdAt,
            uploadStatus: UploadStatus(rawValue: uploadStatus) ?? .pending,
            uploadedAt: uploadedAt
        )
    }

    func update(from media: Media, context: NSManagedObjectContext) {
        id = media.id
        entryID = media.entryID
        type = media.type.rawValue
        localPath = media.localPath
        serverURL = media.serverURL?.absoluteString
        thumbnailPath = media.thumbnailPath
        isEncrypted = media.isEncrypted
        fileSize = media.fileSize
        mimeType = media.mimeType
        width = Int32(media.width)
        height = Int32(media.height)
        duration = media.duration
        createdAt = media.createdAt
        uploadStatus = media.uploadStatus.rawValue
        uploadedAt = media.uploadedAt
    }
}

// MARK: - UserEntity

@objc(UserEntity)
public class UserEntity: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var email: String
    @NSManaged public var name: String?
    @NSManaged public var encryptionTier: String
    @NSManaged public var createdAt: Date
    @NSManaged public var lastLoginAt: Date?
    @NSManaged public var isBiometricEnabled: Bool
}

extension UserEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<UserEntity> {
        return NSFetchRequest<UserEntity>(entityName: "UserEntity")
    }

    func toDomainModel() -> User {
        User(
            id: id,
            email: email,
            name: name,
            encryptionTier: EncryptionTier(rawValue: encryptionTier) ?? .e2e,
            createdAt: createdAt,
            lastLoginAt: lastLoginAt
        )
    }

    func update(from user: User) {
        id = user.id
        email = user.email
        name = user.name
        encryptionTier = user.encryptionTier.rawValue
        createdAt = user.createdAt
        lastLoginAt = user.lastLoginAt
    }
}

// MARK: - Supporting Types

public enum UploadStatus: String, Codable {
    case pending
    case uploading
    case uploaded
    case failed
}

// MARK: - Encryption Service Factory

private struct EncryptionServiceFactory {
    static func service(for tier: EncryptionTier) -> EncryptionServiceProtocol {
        switch tier {
        case .e2e:
            return E2EEncryptionService()
        case .uce:
            return UCEEncryptionService()
        }
    }
}
