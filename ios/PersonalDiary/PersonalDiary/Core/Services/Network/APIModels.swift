//
//  APIModels.swift
//  PersonalDiary
//
//  Created by Claude Code on 2025-10-31.
//  Copyright Â© 2025 Personal Diary Platform. All rights reserved.
//

import Foundation

// MARK: - Authentication

struct RegisterRequest: Encodable {
    let email: String
    let password: String
    let name: String?
    let encryptionTier: String
    let publicKey: String? // For E2E tier
    let encryptedMasterKey: String? // For UCE tier
}

struct RegisterResponse: Decodable {
    let user: UserResponse
    let accessToken: String
    let refreshToken: String
    let recoveryCodes: [String]? // Only for E2E tier
}

struct LoginRequest: Encodable {
    let email: String
    let password: String
}

struct LoginResponse: Decodable {
    let user: UserResponse
    let accessToken: String
    let refreshToken: String
}

struct UserResponse: Decodable {
    let id: UUID
    let email: String
    let name: String?
    let encryptionTier: String
    let createdAt: Date
    let encryptedMasterKey: String? // For UCE tier
}

// MARK: - Entries

struct CreateEntryRequest: Encodable {
    let id: UUID
    let title: String?
    let content: String?
    let encryptedContent: String? // Base64 encoded
    let contentHash: String
    let tags: [String]
    let createdAt: Date
    let source: String
    let sourceID: String?
}

struct UpdateEntryRequest: Encodable {
    let title: String?
    let content: String?
    let encryptedContent: String?
    let contentHash: String
    let tags: [String]
    let updatedAt: Date
}

struct EntryResponse: Decodable {
    let id: UUID
    let title: String?
    let content: String?
    let encryptedContent: String?
    let contentHash: String
    let tags: [TagResponse]
    let media: [MediaResponse]
    let createdAt: Date
    let updatedAt: Date
    let source: String
    let sourceID: String?
    let userId: UUID
}

struct TagResponse: Decodable {
    let id: UUID
    let name: String
    let isAutoGenerated: Bool
}

struct MediaResponse: Decodable {
    let id: UUID
    let type: String
    let url: String
    let thumbnailUrl: String?
    let mimeType: String
    let fileSize: Int64
    let width: Int
    let height: Int
    let duration: Double
    let createdAt: Date
}

// MARK: - Sync

struct SyncEntriesRequest: Encodable {
    let lastSyncTimestamp: Date?
    let entries: [SyncEntryPayload]?
}

struct SyncEntryPayload: Encodable {
    let id: UUID
    let title: String?
    let content: String?
    let encryptedContent: String?
    let contentHash: String
    let tags: [String]
    let createdAt: Date
    let updatedAt: Date
    let source: String
    let sourceID: String?
    let isDeleted: Bool
}

struct SyncEntriesResponse: Decodable {
    let entries: [EntryResponse]
    let deletedEntryIDs: [UUID]
    let lastSyncTimestamp: Date
    let hasMore: Bool
}

struct SyncStatusResponse: Decodable {
    let lastSyncedAt: Date?
    let pendingUploads: Int
    let pendingDownloads: Int
}

// MARK: - Search

struct SearchRequest: Encodable {
    let query: String
    let dateFrom: Date?
    let dateTo: Date?
    let tags: [String]?
    let limit: Int
    let offset: Int
}

struct SearchResponse: Decodable {
    let entries: [EntryResponse]
    let total: Int
    let hasMore: Bool
}

// MARK: - Social

struct FacebookConnectRequest: Encodable {
    let accessToken: String
}

struct FacebookConnectResponse: Decodable {
    let connected: Bool
    let facebookUserId: String
    let facebookUserName: String
}

struct FacebookImportRequest: Encodable {
    let accessToken: String
    let startDate: Date?
    let endDate: Date?
}

struct FacebookImportResponse: Decodable {
    let importedCount: Int
    let entries: [EntryResponse]
}

// MARK: - Helper Extensions

extension Entry {
    /// Converts to API request format
    func toCreateRequest() -> CreateEntryRequest {
        CreateEntryRequest(
            id: id,
            title: title,
            content: isEncrypted ? nil : content,
            encryptedContent: isEncrypted ? encryptedContent?.base64EncodedString() : nil,
            contentHash: contentHash,
            tags: tags.map { $0.name },
            createdAt: createdAt,
            source: source.rawValue,
            sourceID: sourceID
        )
    }

    /// Converts to API update request format
    func toUpdateRequest() -> UpdateEntryRequest {
        UpdateEntryRequest(
            title: title,
            content: isEncrypted ? nil : content,
            encryptedContent: isEncrypted ? encryptedContent?.base64EncodedString() : nil,
            contentHash: contentHash,
            tags: tags.map { $0.name },
            updatedAt: updatedAt
        )
    }

    /// Converts to sync payload
    func toSyncPayload() -> SyncEntryPayload {
        SyncEntryPayload(
            id: id,
            title: title,
            content: isEncrypted ? nil : content,
            encryptedContent: isEncrypted ? encryptedContent?.base64EncodedString() : nil,
            contentHash: contentHash,
            tags: tags.map { $0.name },
            createdAt: createdAt,
            updatedAt: updatedAt,
            source: source.rawValue,
            sourceID: sourceID,
            isDeleted: false
        )
    }

    var encryptedContent: Data? {
        // This would be set during encryption
        nil
    }

    var contentHash: String {
        content.sha256Hash()
    }
}

extension EntryResponse {
    /// Converts API response to domain model
    func toDomainModel() throws -> Entry {
        // Decrypt content if encrypted
        let decryptedContent: String
        if let encryptedContentBase64 = encryptedContent,
           let encryptedData = Data(base64Encoded: encryptedContentBase64) {
            // Content is encrypted, needs decryption
            decryptedContent = "" // Will be decrypted by service layer
        } else {
            decryptedContent = content ?? ""
        }

        return Entry(
            id: id,
            title: title,
            content: decryptedContent,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isEncrypted: encryptedContent != nil,
            encryptionTier: .e2e, // Default, should be determined by user's tier
            tags: tags.map { Tag(id: $0.id, name: $0.name, isAutoGenerated: $0.isAutoGenerated) },
            media: [], // Media handled separately
            source: EntrySource(rawValue: source) ?? .manual,
            sourceID: sourceID,
            syncStatus: .synced,
            lastSyncedAt: Date(),
            serverID: id.uuidString,
            serverUpdatedAt: updatedAt
        )
    }
}
